# React2

# 202230213 박태헌

## 1106 수업내용
1. Styled JSX
    - Styled JSX는 CSS-in-JS 라이브러리 입니다. 내장 모듈이기 때문에 설치가 필요 없습니다.
    - 즉, CSS 속성 지정을 위해 자바스크립트를 사용할 수 있는 라이브러리 입니다.
2. CSS-in-Js의 단점
    - IDE나 코드 편집기 등 개발도구에 대한 지원이 부족합니다.
    - 문법 하이라이팅, 자동 완성, 리늩(lint)기능을 제공하지 않습니다.
    - 코드 내에서 CSS에 대한 의존성이 점점 커지기 때문에 앱 번들도 커지고 느려집니다.
    - 서버에 미리 CSS를 생성해도 클라이언트에서 리액트 하이드레이션이 끝나면 CSS를 다시 생성해야 합니다.
    - 이 때문에 실행 시점에 부하가 커지며, 웹 앱이 계속 느려지게 됩니다. 기능을 추가할 수록 이런 현상은 심해집니다.
3. CSS Module
    - CSS-in-JS의 단점을 회피하기 위한 좋은 방법은 바로 CSS Module입니다.
    - 클래스들은 컴포넌트 스코프를 가집니다.
    - 생성된 HTML 페이지 소스를 보면 class이름이 바뀌어 있는 것을 확인할 수 있습니다.
    - Styled JSX때와 마찬가지로 이런 고유한 이름 때문에 다른 파일이라면 같은 class명을 사용해도 충돌이 일어나지 않습니다.
    - 만일 전역 CSS를 선언하고 싶다면 /styles/globals.css 를 만들고 사용합니다.
    - 파일명은 반드시 globals가 아니어도 되지만 암묵적 합의는 가능하면 지키는 것이 좋습니다.
    - 이제 _app.js에 import 해주면 모든 컴포넌트에 적용됩니다.
    - 또 한가지 방법은 class로 선언된 요소에 :global 키워드를 추가해 줍니다. .button:global{}
    - 셀렉터 컴포지션은 통상적으로 사용할 수 있는 CSS를 만들고 compose 속성을 지정해서 일부..
4. SASS
    - Next에서 기본으로 지원하는 전 처리기입니다.
    - 단 패키지 설치가 필요합니다. $ npm install sass
    - SASS 및 SCSS(Sassy CSS) 문법으로 CSS Module을 만들고 사용할 수 있습니다.
    - styles/Home.module.css 파일 이름을 styles/Home.module.scss로 바꿔주면 됩니다.
    - SASS 기본 설정을 변경해야 하는 경우 next.config.js 설정파일을 변경합니다.

    


## 1030 수업내용
1. 서버가 데이터 불러오기
    - 서버에서는 두 가지 방법으로 HTTP 요청을 만들고 처리할 수 있습니다.
    1) Node의 내장 HTTP 라이브러리를 사용할 수 있습니다.
    다만 서트파티 HTTP 클라이언트와 비교했을 때 설정하고 처리해야 할 작업이 더 많은 편입니다.
    2) HTTP 클라이언트 라이브러리를 사용할 수 있습니다. 가장 유명한 것이 Axios 입니다.
    - Axios를 사용하는 이유는 ...
    1) 클라이언트와 서버 모두에서 동일하게 사용할 수 있고,
    2) npm을 통한 다운로드가 일주일에 약 1,700만 회에 달할 정도로 많이 사용하기 때문입니다.
2. 서버에서 REST API 사용하기
    - REST API를 호출할 때는 public API를 호출할 것인지, private API를 호출할 것인지를 먼저 확인해야 합니다.
    - Public API는 어떤 인증이나 권한도 필요 없음

3. GraphQl API 
    - 2012년에 메타(페이스북)에서 개발
    - API에서 사용할 수 있는 질의어로 REST나 SOAP 같은 방식과는 다른 새로운 관점으로 API 데이터를 다룹니다.

1. REST API 개요
    - REST(Representational State Transfer)란 자원을 이름으로 구분하여 그 자원의 상태를 통신을 통해 주고 받는 것을 의미합니다.

2. Json Server
    - Backend가 개발되기 전이나, 아직 외부 API가 결정되지 않았다면 local에 Json server를 구축하고 Frontend 개발을 하기에 적합한 node 패키지 입니다.
    - 다음 명령으로 json-server를 설치해 줍니다.
    - npm i -g json-server
3. Axios 란?
    - Next.js에서 REST API를 다룰 때는 보통 axios와 fetch 중 하나를 선택하는 경우가 많습니다.
    - 아래는 두 가지 방법의 특징과 장단점을 비교한 내용입니다.
    - [Axios] 
        - 간편한 문법 : 기본적으로 JSON 데이터.
    - [Fetch API]
        - 내장 API : 브라우저에 내장되어 있어 별도의 설치가 필요 없습니다.
        - Promise 기반 : 비동기 작업을 처리하는 데 익숙한 구조입니다.
        - 스트림 처리 : 데이터를 스트리밍으로 처리할 수 있는 기능이 있어, 큰 파일을 처리하는 데 유용합니다.
    - 단점은...
        - json 변환 수동 처리 : 응답에서 json으로 변환할 때 res.json()을 호출해야 합니다.
        - 에러 처리 복잡성 : http..
    - 결론
        - 복잡한 요청이나 에러 처리가 필요한 경우에는 axios가 더 적합할 수 있습니다.
        - 간단한 요청이나 내장된 기능을 활용하고 싶다면 fetch
4. Axios 설치
    - npm i axios
5. Axios 사용하기
    - axios.get()을 통해 받아온 응답 객체인 res는 단순히 JSON 데이터만 담고 있는 것이 아니라, HTTP 통신과 관련된 여러 정보들을 함께 포함하고 있습니다.
    - 예를 들어
        - res.status :  HTTP 응답상태 코드
    - 그런데 비동기 데이터 로딩과 상태 관리가 제대로 고려되지 않았기 때문에 몇 가지 문제가 있을 수 있습니다.
    - 특히, Next.js와 같은 리액트 기반 앱에서 비동기 데이터를 처리할 때 렌더링 주기에 맞게 상태를 관리해야 합니다.

    - [개선할 부분]
        - 1. useState와 useEffect 사용 :   
            - 비동기 데이터를 가져오는 작업은 컴포넌트의 상태로 관리하는 것이 일반적이다. 현재 코드에서는 users 데이터가 비동기적으로 로드되는데, 이를 관리하기 위한 useState와 useEffect 훅이 빠져있습니다.
        - 2. Loading 상태 처리
            - 데이터를 불러오는 동안 사용자가 기다릴 수 있도록 로딩 상태를 추가하는 것이 좋습니다.
    - 로딩 상태 처리 : 데이터를 불러오는 동안 로딩 메시지를 표시하도록 loading 상태를 추가 했습니다.
    - 조건부 렌더링 : 로딩 중일 때, 데이터가 없을 때에 따라 다른 화면을 표시할 수 있도록 했습니다.
    - 이렇게 수정하면 데이터 로딩 중의 문제나 비동기적 데이터 처리와 관련된 오류를 방지할 수 있고, 사용자 경험도 개선할 수 있습니다.
    
    
    
    



## 1023 수업내용
1. Static Resource
    - 정적 자원 중 이미지 파일은 SEO에 많은 영향을 미칩니다.
    - 다운로드 시간이 많이 걸리고, 렌러딩 후에 레이아웃이 변경되든 등 UX에 영향을 미칩니다.
    - 이것을 누적 레이아웃 이동(CLS)이라고 합니다.
    - Image 컴포넌트를 사용하면 CLS 문제를 해결합니다.
    - lazy loading : 이미지 로드 시점을 필요할 때까지 지연시키는 기술입니다.
    - 이미지 사이즈 최적화로 사이즈를 1/10 이하로 줄여 줍니다.
    - Placeholder를 제공합니다.
    - webP와 같은 최신 이미지 포맷 및 최신 포맷을 지원하지 않는 브라우저를 위해 png나 jpdg와 같은 예전 이미지 포맷도 제공합니다.
    - Pixabay나 Unsplash와 같은 외부 이미지 서비스로 이미지를 제공할 수 있습니다.
    - Image 컴포넌트를 사용하면 다양한 props를 전달 할 수 있습니다.
    - 정적 자원은 기본적으로 public 디렉토리에 저장합니다.
1. Image component - Remote
    - Pixabay와 같은 외부 이미지를 사용하려면 next.config.mjs에 URL을 추가해 줘야 합니다.
    - 만일 파일이 없다면 Project root에 추가해 주면 됩니다.

4. 코드 구성과 데이터 불러오기
    - 4장. 애플리케이션의 디렉터리 구조를 어떻게 구성하는지 알아봅니다.
    - 클라이언트와 서버에서 외부 REST API 및 GraphQl API를 사용하는 방법도 알아 봅니다.
    - 프로젝트를 시작할 때 애플리케이션의 확장과 복잡도 증가에 대비해야 함
    - 애플리케이션 상태를 빠르고 간결하게 관리할 수 있는 코드 구성 방법을 알아봅니다.
    - Next.js에서는 특정 파일과 디렉토리가 지정된 위치에 있어야 합니다. _app.js나 _document.js파일
    - Node modules/: Next.js 프로젝트의 의존성 패키지를 설치하는 디렉토리
    - pages/: 애플리케이션 페이지 파일을 저장하고 라우팅 시스템 관리
    - public/: 컴파일된 CSS 및 자바스크립트 파일, 이미지, 아이콘 등의 정적 자원 관리
    - styles/: 스타일링 포맷(CSS, SASS, Less 등)과 관계없이 스타일링 모듈 관리
    - pages/ 디렉토리를 src/ 디렉토리 안으로 옮길 수 있습니다.
    - public/과 node_modules/ 를 제외한 다른 디렉토리는 모두 src/ 로 옮길 수 있습니다.

- 컴포넌트 구성
    - 컴포넌트는 세 가지로 분류하고 각 컴포넌트와 관련된 스타일 및 테스트 파일을 같은 곳에 두어야 합니다.
    - 코드를 더 효율적으로 구성하기 위해 아토믹 디자인 원칙에 따라 디렉토리를 구성합니다.
    - atoms :  가장 기본적인 컴포넌트 관리. 예시. button, input, p와 같은 표준 HTML요소를 감싸는 용도로 사용되는 컴포넌트
    - molecules : atom에 속한 컴포넌트 여러 개를 조합하여 복잡한 구조로 만든 컴포넌트 관리. 예시. input과 label을 합쳐서 만든 새로운 컴포넌트
    - organisms : molecules와 atoms를 섞어서 더 복잡하게 만든 컴포넌트 관리. 예, footer나 carousel 컴포넌트
    - templates : 위에 모든 컴포넌트를 어떻게 배치할지 결정해서 사용자가 접근할 수 있는 페이지

    - button 컴포넌트를 예를 들면 다음과 같이 최소한 세 개의 파일을 만들어야 합니다.
    - 컴포넌트 파일, 스타일 파일, 테스트 파일 입니다.
    - 이렇게 컴포넌트를 구성하면 필요할 때 컴포넌트를 찾고 수정하기 쉽습니다.
- 유틸리티 구성
    - 컴포넌트를 만들지 않는 코드 파일을 유틸리티 스크립트라고 합니다.
    - 예를 들어 애플리케이션의 log파일을 저장하는 코드가 있다면 이것을 컴포넌트로 만들 필요가 있을까요?
    - 이렇게 렌더링에 필요한 컴포넌트가 아닌 기타 필요한 스크립트가 있다면, utilities/ 디렉터리에 별도로 관리하는 것이 좋습니다.
    - 그리고 각 유틸리티에 맞는 테스트 파일도 만듭니다.
- 정적 자원의 구성
    - 정적 자원은 public/ 디렉토리에서 관리합니다.
    - 일반적인 웹 애플리케이션에서는 다음과 같은 정적 자원을 사용합니다.
    - 먼저 public/assests/ 디렉토리를 만들고 파일 유형별로 다시 디렉토리를 추가합니다.
    - 그리고 이곳에 저장된 파일에 접근하고자..--
    - icons/ 디렉토리는 주로 웹 매니페스트에 지공할 아이콘을 관리합니다.
- 스타일 파일 구성
    - 스타일 파일을 앱에서 어떤 스타일 관련 기술을 사용하는가에 따라 구성 달라집니다.
    - Emotion, styled-components, JSS와 같은 CSS-in-Js 프레임워크의 경우 컴포넌트 별로 스타일 파일을 만듭니다.
    - 만일 컬러 팔레트, 테마, 미디어 쿼리와 같은 공통 스타일의 경우는 styles/ 디렉토리를 사용합니다.
- lib 파일 수성
    - lib 파일은 서드파티 라이브러리를 감싸는 스크립트를 말합니다.
    - lib 파일은 특정 라이브러리에 특화된 것입니다. 예. GraphQL
    - 만일 GraphQL을 사용한다면, 클라이언트를 초기화 하고, 질의문과 뮤테이션을 저장하는 등의 작업이 필요
    - 먼저 이런 스크립트를 좀 더 모듈화하기 위햐 프로젝트 root에 lib/graphql/ 디렉토리를 만듭니다.
    - 그리고 다음과 같이 구성하여 관리합니다. 
- 데이터 불러오기
    - Next는 클라이언트와 서버 모두에서 데이터를 불러올 수 있습니다.
    - 서버는 다음 두 가지 상황에서 데이터를 불러올 수 있습니다.
    - 1) 정적 페이지를 만들 때 getStaticProps 함수를 사용해서, 빌드 시점에 데이터를 불러올 수 있습니다.
    - 2) 서버가 페이지를 랜더링할 때 getServerSideProps를 통해, 실행 도중 데이터를 불러올 수도 있습니다.
    - 데이터베이스에서 데이터를 가져올 수도 있겠지만 안전하기 않기 때문에 권장하지 않습니다. 데이터베이스의 접근은 백엔드에서 처리하는 것이 좋습니다.
    - Next는 프런트엔드만 담당하는 것이 좋습니다.
    

## 1002 수업내용

1. App router ? [y/n] . y !
2. src ? [y/n] . y !
3. appR 
4. dir name -> segment

## 0925 수업내용

- Next는 서버사이드 렌더링 외에도 많은 내장 컴포넌트와 함수를 제공합니다.

    - 클라이언트와 서버에서의 라우팅 시스템 작동 방식
    - 페이지 간 이동 최적화
    - Next.js가 정적 자원을 제공하는 방법
    - 자동 이미지 최적화와 새로운 Image 컴포넌트를 사용한 이미지 제공 최적화 기법
    - 컴포넌트에서 HTML 메타데이터를 처리하는 방법
    - _app.js와 _documents.js 파일 내용 및 커스터마이징 방법

1. 라우팅 시스템
    - React의 React Router, Reach Router 등은 클라이언트 라우팅만 구현할 수 있습니다.
    - Next는 파일 시스템 기반 페이지의 라우팅을 합니다.
    - 페이지는 /pages 디렉토리 안의 *.js, *.jsx, *ts, *tsx 파일에서 export한 React 컴포넌트 입니다.
    - /pages/posts/ 디렉토리 내에 Index.js만 간단하게 만들면 localhost:3000/posts로 접속이 가능합니다.




## 0911 수업내용

- 그 밖에 설정..

    - 개발 시 타입스크립트를 주 언어로 쓰고 싶다면 앞서 살펴본 것과 같은 방법으로 타입스크립트 전용 플러그인을 설치하고, 설정을 바꿔주면 됩니다.
    - 프로잭트를 생성할 때 선택할 수 있기 때문에 생성할 때 설정하는 것을 추천합니다.

    - 웹팩은 특정 라이브러리, 페이지, 기능에 대해 컴파일된 코드를 전부 포함하는 번들을 만들어줍니다.
- 하지만..
    - 설정을 바꿀 일은 그렇게 많지 않습니다.
    - 꼭 수정해야 한다면 대부분 next.config.js 파일의 기본값을 변경하는 것으로도 충분합니다.
    - 이 파일을 root에 만들고 객체를 export하면 해당 내용은 Next.js의 기본 설정 값을 덮어씁니다.
    - 만일 기본 웹팩 설정을 바꾸고 싶다면 webpack이라는 키에 새로운 속성값을 지정합니다.

- 몇 가지 일어날 수 있는 오류
    - 처음 Next 프로젝트를 생성할 때 오류로 생성되지 않는 경우가 있습니다.
    이것은 CPA가 설치되어 있지 않아서 생기는 현상입니다.
    - 이런 경우는 다음과 같이 create-react-app을 Gloabal로 설치해 주면 됩니다.
    - $npm i -g create-react-app
    - 이제 프로젝트를 생성합니다.
    - $ npx create-next-app@latest 

- Transpile은 어떻게 동작하나
    - Babel은 ECMAScript와 같은 자바스크립트 최신 버전이나, TypeScript를 이전 버전의 코드로 변환시켜주는 Transpile 도구입니다.
    - 개발자가 작성한 코드 -> Parse -> Transform -> Generate -> 이전 버전의 코드

- 왜 SWC (Speedy Web Compiler)를 사용해야 하는가?
    - babel의 단점
        - Babel로 변환된 코드를 이해하기 어렵다.
        - 원 코드에 비해 변환 코드의 길이가 늘어난다.
        - 변환에 시간이 많이 걸린다.
    - SWC의 장점
        - Next 12 이후 별도의 설정 없이 SWC를 사용할 수 있다. 
- SWC를 프로젝트에 적용하려면?
    - 새로운 프로젝트에 적용하는 것은 다음 명령으로 프로젝트를 생성하면 바로 사용 가능합니다.
    - $ npx create-next-app@latest
    - 또는 $ npx create-next-app@12
    - Next 12 이전 버전의 프로젝트에 적용하려면 다음과 같이 업그레이드 해줘야 합니다.
    - $ npm install next@12
    - 그리고 Babel을 설정했다면 설정 파일 (.babelrc 또는 babel.config.js) 을 삭제해 줍니다.

- ch2 에서는 다음과 같은 내용을 다룹니다.
    - 서버 사이드 랜더링을 사용하여 각 요청별로 페이지를 동적으로 랜더링하는 방법
    - 특정 컴포넌트를 클라이언트에서만 랜더링하는 다양한 방법
    - 빌드 시점에서 정적 페이지를 생성하는 방법
- 서버 사이드 랜더링 (SSR)
    - 생소할 수도 있지만 웹 페이지를 제공하는 가장 흔한 방법입니다.
    - APM을 이용하는 일반적인 웹 페이지 생성이라고 보면 됩니다.
    - 여기에 자바스크립트 코드가 적재되면 동적으로 페이지 내용을 랜더링합니다.
    - Next.js도 이와 같이 동적으로 페이지를 렌더링할 수 있습니다.
    - 그리고 여기에 스크립트 코드를 집어 넣어서 나중에 웹 페이지를 동적으로 처리할 수도 있는데 이를 하이드레이션이라고 합니다.
    - 예를 들면 어떤 사람이 작성한 블로그 글을 한 페이지 모아서 작성해야 한다면 SSR을 이용하는 것이 적당합니다.
    - 서버 사이드 랜더링 -> 자바스크립트가 하이드레이션된 페이지를 전송 -> 클라이언트에서 DOM 위에 각 스크립트 코드를 하이드레이션 : 페이지 새로고침 없이 사용자와 웹 페이지간 상호작용을 가능하게 합니다.

    - 리액트 하이드레이션 덕분에 이 상태에서 웹 앱은 싱글 페이지 애플리케이션(SPA) 처럼 작동할 수 있습니다.
    - CSR과 SSR의 장점을 모두 가지는 것입니다.
    - 특정 전략만 사용한다고 가정하면 SSR이 CSR에 비해 여러가지 장점이 많습니다.

    - SSR의 장점
        - 더 안전한 웹 애플리케이션 : 쿠키관리, 주요 API, 데이터 검증 등과 같은 작업을 서버에서 처리하기 떄문에 중요한 데이터를 클라이언트에 노출할 필요가 없기 떄문입니다.
        - 더 뛰어난 웹 사이트 호환성 : 클라이언트 환경이 자바스크립트를 사용하지 못하거나 오래된 브라우저를 사용하더도 서비스를 제공할 수 있습니다.
        - 더 뛰어난 SEO : 서버가 렌더링한 HTML을 받기 때문에 봇이나 웹 크롤러가 페이지를 랜더링할 필요가 없기 때문입니다.

- SSR이 최적의 랜더링 전략이 아닌 경우
    - 클라이언트가 페이지를 요청할 때마다 페이지를 다시 랜더링할 수 있는 서버가 필요합니다.
    - 다른 방식에 비해 SSR이 더 많은 자원을 소모하고, 더 많은 부하를 보이며, 유지보수 비용도 증가합니다.
    - 페이지에 대한 요청을 처리하는 시간이 길어집니다.
    - 페이지가 외부 API 또는 데이터 소스에 접근해야 한다면, 해당 페이지를 랜더링할 때마다 이를 다시 요청해야 합니다.
    - 페이지 간의 이동은 CSR에 비해 느립니다.
    - 중요한 것은 Next.js가 기본적으로 빌드 시점에 정적으로 페이지를 만든다는 것 입니다.
    - 페이지에서 외부 API를 호출하거나 데이터베이스에 접근하는 등 동적 작업을 해야한다면 해당하는 함수를 페이지에 export 해야 합니다.

- 페이지에 대한 요청이 들어오면 서버가 Rest API를 호출해서 필요한 사용자 정보를 가져옵니다.
- 이 과정은 다음과 같은 세부 단계로 나눌 수 있습니다.
1. getServerSideProps라는 비동기 함수를 export 합니다.
    - 빌드 과정에서 Next.js는 이 함수를 export하는 모든 페이지를 찾아서 서버가 페이지 요청을 처리할 때 getServerSideProps 함수를 호출하도록 만듭니다.
2. getServerSideProps 함수는 props라는 속성값을 갖는 객체를 반환합니다.
    - 이 props는 컴포넌트로 전달되 서버와 클라이언트 모두가 props에 접근할 수 있게 됩니다.
    - fetch API는 서버에서 실행되기 때문에 별도의 폴리필을 끼워 넣을 필요는 없습니다.
3. IndexPage 함수를 수정해서 props를 인자로 받습니다.
    - 이 props는 getServerSideProps 함수에서 반환한 props의 모든 내용을 갖고 있습니다.

- 클라이언트 사이드 랜더링 (CSR)
    - 리액트 앱을 실행하면 렌더링 시작전에 빈 화면이 한동안 유지 되는 것이 보입니다.
    - 이는 서버에서 스크립트와 스타일만 포함된 HTML을 전송하기 때문입니다.
    - 실제 랜더링은 클라이언트에서 이루어 집니다.
    - CSR로 생성한 앱의 HTML을 보면 div 태그 하나 밖에 없습니다. 그래서 빈 화면만 보였던 겁니다.
    -  빌드 과정에서 js와 css파일을 html 페이지에 불러오도록 만들고 root div에 랜더링 합니다.
    
- CSR을 사용할 때의 주요 이점
    - 네이티브 앱처럼 느껴지는 웹 앱
        - 전체 자바스크립트 번들을 다운로드 한다는 것은 렌더링할 모든 페이지가 이미 브라우저에 다운로드 되어 있다는 뜻 입니다.
        - 다른 페이지로 이동해도 서버에 요청할 필요 없이, 바로 페이지를 이동할 수 있습니다.
        - 페이지를 바꾸기 위해 새로고칠 필요가 없습니다.
    - 쉬운 페이지 전환
        - 클라이언트에서의 내비게이션은 브라우저 화면을 새로 고칠 필요없이 다른 페이로의 이동을 가능하게 만듭니다.
        - 페이지 간 전환에 멋진 효과를 넣을 수도 있습니다. 애니메이션을 방해할 요소가 없기 때문입니다.
    - 지연된 로딩과 성능
        - 웹 앱은 최소로 필요한 HTML만 랜더링 합니다.
        - 버튼을 누르면 나오는 모달도 실제 버튼이 눌렸을 때 동적으로 생성하게 됩니다.
    - 서버 부하 감소 - 서버리스 환경에서 웹 앱을 제공할 수도 있습니다.

- 장점은 단점이 될 수도 있습니다.
    - 네트워크 속도가 느린 환경에서는 번들이 모두 다운로드 될 때까지 계속 빈 페이지를 보아야 합니다.
    - 검색 로봇에게도 그 내용은 빈 것으로 보입니다.
    - 번들을 모두 받을 때까지 검색 로봇이 기다리기는 하지만 성능 점수는 낮을 것 입니다.
    - React.useEffect Hook
    - 최근 리액트는 함수형 컴포넌트 사용을 강조하면서 life cycle함수 대신 Hook을 사용합니다.
    - 함수형 컴포넌트 내에서 DOM 조작이나 데이터 불러오기 같은 사이드 이펙트 기능을 구현할 때, useEffect 함수를 사용해서 컴포넌트가 마운트된 후, 해당 기능을 실행하도록 만들 수 있습니다.

- 코드 설명(40~41P)
    - CSR인 React에서는 다음 코드가 문제없이 작동하지만 Next.js의 빌드과정에서는 문제가 생깁니다.
    - Highlight.js 라이브러리가 document라는 전역 변수를 사용하는데, 이 변수는 Node.js에서 제공하지 않으며 오직 브라우저에서만 접근할 수 있기 때문입니다.
    - 이 문제는 hljs 호출을 useEffect 훅으로 감싸서 해결할 수 있습니다.
- process.browser 변수
    - 서버에서 랜더링할 때 브라우저 전용 API로 인한 문제를 다른 방법으로 해결할 수도 있습니다.
    - process.browser 값에 따라서 스크립트와 컴포넌트를 조건별로 실행하는 것 입니다.
    - 이 변수는 Boolean 값으로, 코드를 클라이언트에서 실행하면 true, 서버에서 실행하면 false 값을 갖습니다.
    - 다음 코드를 실행하면 처음에는 "~server~side"라고 표시되고, 리액트 하이드레이션이 끝나면 바로 "~"
    - 대신 좀 더 정확한 의미를 갖는 typeof window를 사용할 수 있습니다.
    - typeof window를 서버에서 실행하면 그 값은 문자연 "undefined"가 되며, 그렇지 않으면 클라이언트에서 실행하게 됩니다.
- 동적 컴포넌트 로딩 - dynamic
    - 앞서 React.useEffect 훅을 사용하여 브라우저에서 코드를 실행하는 경우에만 컴포넌트를 렌더링해 보았습니다.
    - dynamic 함수로도 똑같이 동작하게 할 수 있습니다.
    - 다음 코드를 실행하면 Highligt 컴포넌트를 동적 임포트 (dynamic import)로 불러옵니다.
    - 즉, ssr:fasle 옵션으로 클라이언트에서만 코드를 실행한다고 명시하는 것입니다.

- 정적 사이트 생성 (SSG : Static Site Generation)
    - SSG는 일부 또는 전체 페이지를 빌드 시점에 미리 랜더링 합니다.
    - SSG는 SSR 및 CSR과 비교했을 때 다음과 같은 장점이 있습니다.
1. 쉬운 확장
    - 정적 페이지는 단순 HTML 파일이므로 CDN을 통해 파일을 제공하거나, 캐시에 저장하기 쉽습니다.
2. 뛰어난 성능
    - 빌드 시점에 HTML 페이지를 미리 렌더링하기 때문에 페이지를 요청해도 클라이언트나 서버가 무언가를 처리할 필요가 없습니다.
3. 더 안전한 API 요청
    - 외부 API를 호추랗거나, 데이터베이스에 접근하거나, 보호해야할 데이터에 접근할 일이 없습니다.
- SSG는 높은 확장성과 뛰어난 성능을 보이는 프런트엔드 애플리케이션을 만들고 싶을 때 가장 좋은 방법입니다.
- 한 가지 문제점은 일단 웹 페이지를 만들고 나면 다음 배포 전까지 내용이 변하지 않는다는 것입니다.
- 조금이라도 수정하려면 필요한 데이터를 가져와서 수정하고 다시 생성하는 과정을 반복해야 합니다.
- 이런 문제 때문에 나온 방법이 바로 "증분 정적 재생성(ISR : Incremental Static Regeneation)" 입니다.
- 예를 들어 동적 콘텐츠를 제공하지만 해당 콘텐츠 데이터를 로딩 하는데 시간이 오래 걸린다면, SSG와 ISR을 함께 사용하여 문제를 해결할 수 있습니다.
- 많은 양의 데이터를 필요로 하는 복잡한 대시보드를 만든다면, 데이터를 불러오기 위한 REST API호출에 수 초가 소요됩니다.
- 만일 데이터가 자주 변하지 않는다며뉴 SSG와 ISR을 사용해서 데이터를 10분동안 캐싱할 수 있습니다.

1. getStaticProps 함수를 사용합니다
2. 빌드 과정에서 페이지를 랜더링할 때 이 함수를 호출해서 필요한 데이터 등을 가져오며, 다음 번 빌드 시점까지 더 이상 호출하지 않습니다.
3. 빌드 과정에서 페이지의 내용을 getStaticProps 함수가 반환한 객체의 값으로 채웁니다. 그리고 이 페이지는 빌드를 거쳐 정적 페이지로 만들어집니다.
4. 처음 10분간 해당 페이지를 요청하는 모든 사용자는 동일한 정적 페이지를 제공받습니다.
5. 10분이 지나고 해당 페이지에 대한 새로운 요청이 들어오면 Next.js는 이 페이지를 서버에서 다시 랜더링하고 getStaticProps 함수를 다시 호출합니다.
6. 이후 10분간 동일한 페이지에 대한 모든 요청에 대해 새로 만든 정적 페이지를 제공합니다.
7. 만일 10분이 지난 후에 페이지에 대한 새로운 요청이 없다면 새로 빌드하지 않습니다.



## 0904 수업내용

- 기본 환경설정 정리 (0904 환경설정)

파워쉘 관리자 권한으로 열고 아래 내용 입력하기

Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

이러면 설치 중...끝나면 확인완료를 위해

choco -v 로 버전 체크

https://community.chocolatey.org/packages?q=git

맨 위에 있는 거 설치 choco install git 똑같이 입력

node -v
npm -v
npx -v 로 버전 체크 (설치 확인)

(
   필수 아닌 거 같긴 한데 메모
   비쥬얼스튜디오코드를 zip으로 다운 받아서 D드라이브에 옮김
   교수님 진도 똑같이 하려면 이렇게
)


폴더 만들기 (C 드라이븐던 D 드라이브던)

npm i -g create-react-app

npx create-next-app@latest

y 치고 프로젝트 이름 page-router 입력

차례대로 no yes no no no yes 그리고 엔터하면 설치

그리고 설치한 page-router로 폴더이동

npm run dev 명령어 실행 

윈도우 기본 앱 설정으로 마이크로소프트로 켜지면 창을 크롬으로 바꿀 수 있음


인덱스.js 파일을 카피. 그리고 카피한 이름을 about.js 로 수정

그리고 about.js의 21번째 라인을 about.js로 수정


다시 원래의 폴더로 돌아와서 npx create-next-app@latest 입력

프로젝트 이름은 app-router

차례대로 n, y, n, y, y, 엔터

app-router 만든 폴더로 이동해서 npm run dev 입력

아까랑 똑같이 이번엔 page.js를 카피해서 이름 바꾸기 >> about.js 로

했다가..? 다시 바꿈 그리고 src app에서 about 폴더 생성하고 about.js 넣기

그리고 이름을 page.js로 재변경..? << 일단 이렇게 실행은 가능.

page.js 확인하기

2 번째 라인 확인 : import styles from "../page.module.css";

10 번째 라인 확인 :   <code className={styles.code}>src/app/about/page.js</code>


https://github.com/vercel (참고용 자료)


그리고 다시 원래의 d 드라이브로 돌아오기

npx create-next-app --example blog-starter

프로젝트 이름 my-blog

다시 my-blog 폴더 선택해서 열기

깃베쉬 명령어 입력 : npm run dev  >>> 이러면 열리는 걸 확인가능



